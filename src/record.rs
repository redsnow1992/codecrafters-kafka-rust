use std::collections::HashMap;

use kafka_protocol::{protocol::buf::ByteBuf, records::{Record, RecordSet}};
use uuid::Uuid;

pub fn to_i8(byte: u8) -> i8 {
    match byte {
        0x01 => -1,
        0x03 => 3,
        0x04 => 4,
        _ => {
            u8::from_be(byte >> 1) as i8
        }
    }
}

pub fn to_i16(bytes: &[u8]) -> i16 {
    u8::from_be(bytes[0] >> 1) as i16
}

// type: 
// 02: TopicRecord
// 03: PartitionRecord
// 12: Feature Level Record

#[derive(Debug)]
pub struct TopicRecord {
    pub name: String,
    pub topic_id: Uuid,
}

#[derive(Debug)]
pub struct FeatureLevelRecord {
    pub name: String,
    pub metadata_version: i16,
}

#[derive(Debug)]
pub struct PartitionRecord {
    pub partition_id: i32,
    pub topic_id: Uuid,
}

#[derive(Debug)]
pub enum RecordValue {
    TopicRecord(TopicRecord),
    FeatureLevelRecord(FeatureLevelRecord),
    PartitionRecord(PartitionRecord),
}

pub fn parse_string_by_length<B: ByteBuf>(buf: &mut B) -> String {
    let len = buf.get_u8() as usize - 1;
    let mut str_buf = vec![0; len];
    str_buf.copy_from_slice(&buf.get_bytes(len));
    String::from_utf8(str_buf).unwrap()
}

pub fn parse_uuid<B: ByteBuf>(buf: &mut B) -> Uuid {
    let mut uuid_buf = [0; 16];
    buf.try_copy_to_slice(&mut uuid_buf).unwrap();
    Uuid::from_bytes(uuid_buf).into()
}

pub fn extract_record_value(record: &Record) -> RecordValue {
    if let Some(ref mut value) = record.value.clone() {
        parse_record_value( value)
    } else {
        panic!("parse error")
    }
}

pub fn parse_record_value<B: ByteBuf>(buf: &mut B) -> RecordValue {
    buf.get_i8(); // frame version
    let value_type = buf.get_i8(); // type
    buf.get_i8(); // version
    match value_type {
        0x0c => {
            let name = parse_string_by_length(buf);
            let metadata_version = buf.get_i16();
            RecordValue::FeatureLevelRecord(FeatureLevelRecord { name, metadata_version })
        },
        0x02 => {
            let name = parse_string_by_length(buf);
            let topic_id = parse_uuid(buf);
            RecordValue::TopicRecord(TopicRecord { name, topic_id })
        },
        0x03 => {
            let partition_id = buf.get_i32();
            let topic_id = parse_uuid(buf);
            RecordValue::PartitionRecord(PartitionRecord { partition_id, topic_id })
        }
        _ => {
            panic!("Unsupported record value version");
        }
    }
}

// record_set to topic_id -> vec[partition_id]
pub fn record_set_to_topic(record_sets: Vec<RecordSet>) -> HashMap<String, (Uuid, Vec<i32>)> {
    let mut ret = HashMap::new();
    for record_set in record_sets.iter() {
        if record_set.records.len() > 1 {
            let record_value = extract_record_value(&record_set.records[0]);
            let (name, topic_id) = match record_value {
                RecordValue::TopicRecord(tr) => {
                    (tr.name, tr.topic_id)
                }
                _ => continue
            };
            let partition_ids = record_set.records[1..]
                .iter()
                .flat_map(|r| {
                    let record_value = extract_record_value(r);
                    match record_value {
                        RecordValue::PartitionRecord(pr) => {
                            Some(pr.partition_id)
                        }
                        _ => None
                    }
                })
                .collect();
            ret.insert(name, (topic_id, partition_ids));
        }
    }
    ret
}

#[cfg(test)]
mod tests {
    use bytes::BytesMut;
    use kafka_protocol::records::RecordBatchDecoder;

    use crate::record::{extract_record_value, parse_record_value, to_i16, to_i8, RecordValue};

    #[test]
    fn test_to_i8() {
        assert_eq!(to_i8(0x3c), 30);
        assert_eq!(to_i8(0x01), -1);
        assert_eq!(to_i8(0x30), 24);
        assert_eq!(to_i8(0x03), 3);
    }

    #[test]
    fn test_to_i16() {
        assert_eq!(to_i16(&[0x90, 0x01]), 72);
        assert_eq!(to_i16(&[0x82, 0x01]), 65);
    }

    #[test]
    fn test_build_records_from_bytes() {
        let bytes = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0x00,0x00,0x00,0x01,
            0x02,0xb0,0x69,0x45,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x91,0xe0,
            0x5a,0xf8,0x18,0x00,0x00,0x01,0x91,0xe0,0x5a,0xf8,0x18,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x01,0x3a,0x00,0x00,
            0x00,0x01,0x2e,0x01,0x0c,0x00,0x11,0x6d,0x65,0x74,0x61,0x64,0x61,0x74,0x61,0x2e,
            0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x01,0x00,0x00,0x00,0xe4,0x00,0x00,0x00,0x01,0x02,0x24,0xdb,0x12,0xdd,
            0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x01,0x91,0xe0,0x5b,0x2d,0x15,0x00,0x00,
            0x01,0x91,0xe0,0x5b,0x2d,0x15,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x03,0x3c,0x00,0x00,0x00,0x01,0x30,0x01,0x02,
            0x00,0x04,0x73,0x61,0x7a,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x00,0x00,
            0x00,0x00,0x00,0x00,0x91,0x00,0x00,0x90,0x01,0x00,0x00,0x02,0x01,0x82,0x01,0x01,
            0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x00,
            0x00,0x00,0x00,0x00,0x00,0x91,0x02,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x01,
            0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x10,
            0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
            0x00,0x90,0x01,0x00,0x00,0x04,0x01,0x82,0x01,0x01,0x03,0x01,0x00,0x00,0x00,0x01,
            0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x91,
            0x02,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x40,
            0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
        ];
        let mut buf = BytesMut::new();
        buf.extend_from_slice(&bytes);
        if let Ok(record_batch) = RecordBatchDecoder::decode_all(&mut buf) {
            assert_eq!(2, record_batch.len());
            let rb1 = &record_batch[0];
            
            let rb2 = &record_batch[1];
            let record = &rb2.records[0];
            let mut record_value = record.value.clone();

            if let Some(ref mut value) = &mut record_value {
                let record_value = parse_record_value(value);
                match record_value {
                    RecordValue::TopicRecord(tr) => assert_eq!("saz", tr.name),
                    _ => panic!("unreachable"),
                }
            } else {
                panic!("error parse record value");
            }
        } else {
            panic!("error parse record batch");
        }
    }

    #[test]
    fn test_build_records_from_bytes2() {
        let bytes = vec![
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x01, 0x02, 0xb0, 0x69, 0x45, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5a, 0xf8, 0x18, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5a, 0xf8, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x00, 0x00, 0x00, 0x01, 0x2e, 0x01, 0x0c, 0x00, 0x11, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x01, 0x02, 0xbd, 0x2d, 0xfd, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x00, 0x00, 0x00, 0x01, 0x30, 0x01, 0x02, 0x00, 0x04, 0x62, 0x61, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x02, 0x01, 0x82, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x01, 0x02, 0x96, 0x4a, 0xcd, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x00, 0x00, 0x00, 0x01, 0x30, 0x01, 0x02, 0x00, 0x04, 0x62, 0x61, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x02, 0x01, 0x82, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x00, 0x01, 0x02, 0x87, 0x02, 0xc1, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0x00, 0x00, 0x01, 0x91, 0xe0, 0x5b, 0x2d, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0x3c, 0x00, 0x00, 0x00, 0x01, 0x30, 0x01, 0x02, 0x00, 0x04, 0x66, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x02, 0x01, 0x82, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x04, 0x01, 0x82, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x02, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00
        ];
        let mut buf = BytesMut::new();
        buf.extend_from_slice(&bytes);
        if let Ok(record_batch) = RecordBatchDecoder::decode_all(&mut buf) {
            for record_set in record_batch.iter() {
                println!("----------");
                for record in record_set.records.iter() {
                    let record_value = extract_record_value(record);
                    println!("{:?}", record_value);
                }
            }
        }
    }
}